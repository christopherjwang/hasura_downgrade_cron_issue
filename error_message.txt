{"internal":{"statement":"-- create tables to store hasura metadata\n\n/* Note [Reference system columns using type name]\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nWhile working on #3394, I (Alexis) discovered that Postgres seems to sometimes generate very bad\nquery plans when joining against the system catalogs if we store things like table/schema names\nusing type `text` rather than type `name`, the latter of which is used internally. The two types are\ncompatible in the sense that Postgres will willingly widen `name` to `type` automatically, but\n`name`s are restricted to 64 bytes.\n\nUsing `name` for ordinary user data would be a deep sin, but using it to store references to actual\nPostgres identifiers makes a lot of sense, so using `name` in those places is alright. And by doing\nso, we make Postgres much more likely to take advantage of certain indexes that can significantly\nimprove query performance. */\n\nCREATE TABLE hdb_catalog.hdb_table\n(\n    table_schema name, -- See Note [Reference system columns using type name]\n    table_name name,\n    configuration jsonb,\n    is_system_defined boolean default false,\n    is_enum boolean NOT NULL DEFAULT false,\n\n    PRIMARY KEY (table_schema, table_name)\n);\n\nCREATE TABLE hdb_catalog.hdb_relationship\n(\n    table_schema name, -- See Note [Reference system columns using type name]\n    table_name name,\n    rel_name   TEXT,\n    rel_type   TEXT CHECK (rel_type IN ('object', 'array')),\n    rel_def    JSONB NOT NULL,\n    comment    TEXT NULL,\n    is_system_defined boolean default false,\n\n    PRIMARY KEY (table_schema, table_name, rel_name),\n    FOREIGN KEY (table_schema, table_name) REFERENCES hdb_catalog.hdb_table(table_schema, table_name) ON UPDATE CASCADE\n);\n\nCREATE TABLE hdb_catalog.hdb_remote_relationship\n(\n  remote_relationship_name TEXT NOT NULL,\n  table_schema name NOT NULL,\n  table_name name NOT NULL,\n  definition JSONB NOT NULL,\n  PRIMARY KEY (remote_relationship_name, table_schema, table_name),\n  FOREIGN KEY (table_schema, table_name) REFERENCES hdb_catalog.hdb_table(table_schema, table_name) ON UPDATE CASCADE\n);\n\nCREATE TABLE hdb_catalog.hdb_permission\n(\n    table_schema name, -- See Note [Reference system columns using type name]\n    table_name name,\n    role_name  TEXT,\n    perm_type  TEXT CHECK(perm_type IN ('insert', 'select', 'update', 'delete')),\n    perm_def   JSONB NOT NULL,\n    comment    TEXT NULL,\n    is_system_defined boolean default false,\n\n    PRIMARY KEY (table_schema, table_name, role_name, perm_type),\n    FOREIGN KEY (table_schema, table_name) REFERENCES hdb_catalog.hdb_table(table_schema, table_name) ON UPDATE CASCADE\n);\n\nCREATE VIEW hdb_catalog.hdb_permission_agg AS\nSELECT\n    table_schema,\n    table_name,\n    role_name,\n    json_object_agg(perm_type, perm_def) as permissions\nFROM\n    hdb_catalog.hdb_permission\nGROUP BY\n    table_schema, table_name, role_name;\n\nCREATE VIEW hdb_catalog.hdb_foreign_key_constraint AS\nSELECT\n    q.table_schema :: text,\n    q.table_name :: text,\n    q.constraint_name :: text,\n    min(q.constraint_oid) :: integer as constraint_oid,\n    min(q.ref_table_table_schema) :: text as ref_table_table_schema,\n    min(q.ref_table) :: text as ref_table,\n    json_object_agg(ac.attname, afc.attname) as column_mapping,\n    min(q.confupdtype) :: text as on_update,\n    min(q.confdeltype) :: text as on_delete,\n    json_agg(ac.attname) as columns,\n    json_agg(afc.attname) as ref_columns\nFROM\n    (SELECT\n        ctn.nspname AS table_schema,\n        ct.relname AS table_name,\n        r.conrelid AS table_id,\n        r.conname as constraint_name,\n        r.oid as constraint_oid,\n        cftn.nspname AS ref_table_table_schema,\n        cft.relname as ref_table,\n        r.confrelid as ref_table_id,\n        r.confupdtype,\n        r.confdeltype,\n        UNNEST (r.conkey) AS column_id,\n        UNNEST (r.confkey) AS ref_column_id\n    FROM\n        pg_catalog.pg_constraint r\n        JOIN pg_catalog.pg_class ct\n          ON r.conrelid = ct.oid\n        JOIN pg_catalog.pg_namespace ctn\n          ON ct.relnamespace = ctn.oid\n        JOIN pg_catalog.pg_class cft\n          ON r.confrelid = cft.oid\n        JOIN pg_catalog.pg_namespace cftn\n          ON cft.relnamespace = cftn.oid\n    WHERE\n        r.contype = 'f'\n    ) q\n    JOIN pg_catalog.pg_attribute ac\n      ON q.column_id = ac.attnum\n         AND q.table_id = ac.attrelid\n    JOIN pg_catalog.pg_attribute afc\n      ON q.ref_column_id = afc.attnum\n         AND q.ref_table_id = afc.attrelid\nGROUP BY q.table_schema, q.table_name, q.constraint_name;\n\nCREATE VIEW hdb_catalog.hdb_check_constraint AS\nSELECT\n    n.nspname :: text AS table_schema,\n    ct.relname :: text AS table_name,\n    r.conname :: text as constraint_name,\n    pg_catalog.pg_get_constraintdef(r.oid, true) as check\nFROM\n    pg_catalog.pg_constraint r\n    JOIN pg_catalog.pg_class ct\n      ON r.conrelid = ct.oid\n    JOIN pg_catalog.pg_namespace n\n      ON ct.relnamespace = n.oid\nWHERE\n    r.contype = 'c';\n\nCREATE VIEW hdb_catalog.hdb_unique_constraint AS\nSELECT\n    tc.table_name,\n    tc.constraint_schema AS table_schema,\n    tc.constraint_name as constraint_name,\n    json_agg(kcu.column_name) AS columns\nFROM\n    information_schema.table_constraints tc\n    JOIN information_schema.key_column_usage AS kcu\n    USING (constraint_schema, constraint_name)\nWHERE\n    constraint_type = 'UNIQUE'\nGROUP BY\n    tc.table_name, tc.constraint_schema, tc.constraint_name;\n\nCREATE VIEW hdb_catalog.hdb_primary_key AS\nSELECT\n  tc.table_schema,\n  tc.table_name,\n  tc.constraint_name,\n  json_agg(constraint_column_usage.column_name) AS columns\nFROM\n  (\n    information_schema.table_constraints tc\n    JOIN (\n      SELECT\n        x.tblschema AS table_schema,\n        x.tblname AS table_name,\n        x.colname AS column_name,\n        x.cstrname AS constraint_name\n      FROM\n        (\n          SELECT\n            DISTINCT nr.nspname,\n            r.relname,\n            a.attname,\n            c.conname\n          FROM\n            pg_namespace nr,\n            pg_class r,\n            pg_attribute a,\n            pg_depend d,\n            pg_namespace nc,\n            pg_constraint c\n          WHERE\n            (\n              (nr.oid = r.relnamespace)\n              AND (r.oid = a.attrelid)\n              AND (d.refclassid = ('pg_class' :: regclass) :: oid)\n              AND (d.refobjid = r.oid)\n              AND (d.refobjsubid = a.attnum)\n              AND (d.classid = ('pg_constraint' :: regclass) :: oid)\n              AND (d.objid = c.oid)\n              AND (c.connamespace = nc.oid)\n              AND (c.contype = 'c' :: \"char\")\n              AND (\n                r.relkind = ANY (ARRAY ['r'::\"char\", 'p'::\"char\"])\n              )\n              AND (NOT a.attisdropped)\n            )\n          UNION ALL\n          SELECT\n            nr.nspname,\n            r.relname,\n            a.attname,\n            c.conname\n          FROM\n            pg_namespace nr,\n            pg_class r,\n            pg_attribute a,\n            pg_namespace nc,\n            pg_constraint c\n          WHERE\n            (\n              (nr.oid = r.relnamespace)\n              AND (r.oid = a.attrelid)\n              AND (nc.oid = c.connamespace)\n              AND (\n                r.oid = CASE\n                  c.contype\n                  WHEN 'f' :: \"char\" THEN c.confrelid\n                  ELSE c.conrelid\n                END\n              )\n              AND (\n                a.attnum = ANY (\n                  CASE\n                    c.contype\n                    WHEN 'f' :: \"char\" THEN c.confkey\n                    ELSE c.conkey\n                  END\n                )\n              )\n              AND (NOT a.attisdropped)\n              AND (\n                c.contype = ANY (ARRAY ['p'::\"char\", 'u'::\"char\", 'f'::\"char\"])\n              )\n              AND (\n                r.relkind = ANY (ARRAY ['r'::\"char\", 'p'::\"char\"])\n              )\n            )\n        ) x(\n          tblschema,\n          tblname,\n          colname,\n          cstrname\n        )\n    ) constraint_column_usage ON (\n      (\n        (tc.constraint_name) :: text = (constraint_column_usage.constraint_name) :: text\n        AND (tc.table_schema) :: text = (constraint_column_usage.table_schema) :: text\n        AND (tc.table_name) :: text = (constraint_column_usage.table_name) :: text\n      )\n    )\n  )\nWHERE\n  ((tc.constraint_type) :: text = 'PRIMARY KEY' :: text)\nGROUP BY\n  tc.table_schema,\n  tc.table_name,\n  tc.constraint_name;\n\nCREATE FUNCTION hdb_catalog.inject_table_defaults(view_schema text, view_name text, tab_schema text, tab_name text) RETURNS void\nLANGUAGE plpgsql AS $$\n    DECLARE\n        r RECORD;\n    BEGIN\n      FOR r IN SELECT column_name, column_default FROM information_schema.columns WHERE table_schema = tab_schema AND table_name = tab_name AND column_default IS NOT NULL LOOP\n          EXECUTE format('ALTER VIEW %I.%I ALTER COLUMN %I SET DEFAULT %s;', view_schema, view_name, r.column_name, r.column_default);\n      END LOOP;\n    END;\n$$;\n\n\nCREATE TABLE hdb_catalog.event_triggers\n(\n  name TEXT PRIMARY KEY,\n  type TEXT NOT NULL,\n  schema_name TEXT NOT NULL,\n  table_name TEXT NOT NULL,\n  configuration JSON,\n  comment TEXT\n);\n\n-- since we removed the foreign key constraint with hdb_catalog.hdb_table which had 'ON UPDATE CASCADE'\nCREATE OR REPLACE FUNCTION hdb_catalog.event_trigger_table_name_update()\nRETURNS TRIGGER\nLANGUAGE PLPGSQL\nAS\n$$\nBEGIN\n  IF (NEW.table_schema, NEW.table_name) <> (OLD.table_schema, OLD.table_name)  THEN\n    UPDATE hdb_catalog.event_triggers\n    SET schema_name = NEW.table_schema, table_name = NEW.table_name\n    WHERE (schema_name, table_name) = (OLD.table_schema, OLD.table_name);\n  END IF;\n  RETURN NEW;\nEND;\n$$;\n\nCREATE TRIGGER event_trigger_table_name_update_trigger\nAFTER UPDATE ON hdb_catalog.hdb_table\nFOR EACH ROW EXECUTE PROCEDURE hdb_catalog.event_trigger_table_name_update();\n\n\nCREATE TABLE hdb_catalog.hdb_function\n(\n  function_schema TEXT,\n  function_name TEXT,\n  configuration JSONB NOT NULL DEFAULT '{}'::jsonb,\n  is_system_defined boolean default false,\n\n  PRIMARY KEY (function_schema, function_name)\n);\n\nCREATE VIEW hdb_catalog.hdb_function_agg AS\n(\nSELECT\n  p.proname::text AS function_name,\n  pn.nspname::text AS function_schema,\n  pd.description,\n\n  CASE\n    WHEN (p.provariadic = (0) :: oid) THEN false\n    ELSE true\n  END AS has_variadic,\n\n  CASE\n    WHEN (\n      (p.provolatile) :: text = ('i' :: character(1)) :: text\n    ) THEN 'IMMUTABLE' :: text\n    WHEN (\n      (p.provolatile) :: text = ('s' :: character(1)) :: text\n    ) THEN 'STABLE' :: text\n    WHEN (\n      (p.provolatile) :: text = ('v' :: character(1)) :: text\n    ) THEN 'VOLATILE' :: text\n    ELSE NULL :: text\n  END AS function_type,\n\n  pg_get_functiondef(p.oid) AS function_definition,\n\n  rtn.nspname::text as return_type_schema,\n  rt.typname::text as return_type_name,\n  rt.typtype::text as return_type_type,\n  p.proretset AS returns_set,\n  ( SELECT\n      COALESCE(json_agg(\n        json_build_object('schema', q.\"schema\",\n                          'name', q.\"name\",\n                          'type', q.\"type\"\n                         )\n      ), '[]')\n    FROM\n      (\n        SELECT\n          pt.typname AS \"name\",\n          pns.nspname AS \"schema\",\n          pt.typtype AS \"type\",\n          pat.ordinality\n        FROM\n          unnest(\n            COALESCE(p.proallargtypes, (p.proargtypes) :: oid [])\n          ) WITH ORDINALITY pat(oid, ordinality)\n          LEFT JOIN pg_type pt ON ((pt.oid = pat.oid))\n          LEFT JOIN pg_namespace pns ON (pt.typnamespace = pns.oid)\n        ORDER BY pat.ordinality ASC\n      ) q\n   ) AS input_arg_types,\n  to_json(COALESCE(p.proargnames, ARRAY [] :: text [])) AS input_arg_names,\n  p.pronargdefaults AS default_args,\n  p.oid::integer AS function_oid\nFROM\n  pg_proc p\n  JOIN pg_namespace pn ON (pn.oid = p.pronamespace)\n  JOIN pg_type rt ON (rt.oid = p.prorettype)\n  JOIN pg_namespace rtn ON (rtn.oid = rt.typnamespace)\n  LEFT JOIN pg_description pd ON p.oid = pd.objoid\nWHERE\n  pn.nspname :: text NOT LIKE 'pg_%'\n  AND pn.nspname :: text NOT IN ('information_schema', 'hdb_catalog', 'hdb_views')\n  AND (NOT EXISTS (\n          SELECT\n            1\n          FROM\n            pg_aggregate\n          WHERE\n            ((pg_aggregate.aggfnoid) :: oid = p.oid)\n        )\n    )\n);\n\nCREATE TABLE hdb_catalog.remote_schemas (\n  id BIGSERIAL PRIMARY KEY,\n  name TEXT UNIQUE,\n  definition JSON,\n  comment TEXT\n);\n\nCREATE TABLE hdb_catalog.hdb_schema_update_event (\n  instance_id uuid NOT NULL,\n  occurred_at timestamptz NOT NULL DEFAULT NOW(),\n  invalidations json NOT NULL\n);\n\nCREATE UNIQUE INDEX hdb_schema_update_event_one_row\n  ON hdb_catalog.hdb_schema_update_event ((occurred_at IS NOT NULL));\n\nCREATE FUNCTION hdb_catalog.hdb_schema_update_event_notifier() RETURNS trigger AS\n$function$\n  DECLARE\n    instance_id uuid;\n    occurred_at timestamptz;\n    invalidations json;\n    curr_rec record;\n  BEGIN\n    instance_id = NEW.instance_id;\n    occurred_at = NEW.occurred_at;\n    invalidations = NEW.invalidations;\n    PERFORM pg_notify('hasura_schema_update', json_build_object(\n      'instance_id', instance_id,\n      'occurred_at', occurred_at,\n      'invalidations', invalidations\n      )::text);\n    RETURN curr_rec;\n  END;\n$function$\nLANGUAGE plpgsql;\n\nCREATE TRIGGER hdb_schema_update_event_notifier AFTER INSERT OR UPDATE ON\n  hdb_catalog.hdb_schema_update_event FOR EACH ROW EXECUTE PROCEDURE\n  hdb_catalog.hdb_schema_update_event_notifier();\n\nCREATE VIEW hdb_catalog.hdb_table_info_agg AS\n  SELECT\n    schema.nspname AS table_schema,\n    \"table\".relname AS table_name,\n\n    -- This field corresponds to the `CatalogTableInfo` Haskell type\n    jsonb_build_object(\n      'oid', \"table\".oid :: integer,\n      'columns', coalesce(columns.info, '[]'),\n      'primary_key', primary_key.info,\n      -- Note: unique_constraints does NOT include primary key constraints!\n      'unique_constraints', coalesce(unique_constraints.info, '[]'),\n      'foreign_keys', coalesce(foreign_key_constraints.info, '[]'),\n      'view_info', CASE \"table\".relkind WHEN 'v' THEN jsonb_build_object(\n        'is_updatable', ((pg_catalog.pg_relation_is_updatable(\"table\".oid, true) & 4) = 4),\n        'is_insertable', ((pg_catalog.pg_relation_is_updatable(\"table\".oid, true) & 8) = 8),\n        'is_deletable', ((pg_catalog.pg_relation_is_updatable(\"table\".oid, true) & 16) = 16)\n      ) END,\n      'description', description.description\n    ) AS info\n\n  -- table & schema\n  FROM pg_catalog.pg_class \"table\"\n  JOIN pg_catalog.pg_namespace schema\n    ON schema.oid = \"table\".relnamespace\n\n  -- description\n  LEFT JOIN pg_catalog.pg_description description\n    ON  description.classoid = 'pg_catalog.pg_class'::regclass\n    AND description.objoid = \"table\".oid\n    AND description.objsubid = 0\n\n  -- columns\n  LEFT JOIN LATERAL\n    ( SELECT jsonb_agg(jsonb_build_object(\n        'name', \"column\".attname,\n        'position', \"column\".attnum,\n        'type', coalesce(base_type.typname, \"type\".typname),\n        'is_nullable', NOT \"column\".attnotnull,\n        'description', pg_catalog.col_description(\"table\".oid, \"column\".attnum)\n      )) AS info\n      FROM pg_catalog.pg_attribute \"column\"\n      LEFT JOIN pg_catalog.pg_type \"type\"\n        ON \"type\".oid = \"column\".atttypid\n      LEFT JOIN pg_catalog.pg_type base_type\n        ON \"type\".typtype = 'd' AND base_type.oid = \"type\".typbasetype\n      WHERE \"column\".attrelid = \"table\".oid\n        -- columns where attnum <= 0 are special, system-defined columns\n        AND \"column\".attnum > 0\n        -- dropped columns still exist in the system catalog as “zombie” columns, so ignore those\n        AND NOT \"column\".attisdropped\n    ) columns ON true\n\n  -- primary key\n  LEFT JOIN LATERAL\n    ( SELECT jsonb_build_object(\n        'constraint', jsonb_build_object('name', class.relname, 'oid', class.oid :: integer),\n        'columns', coalesce(columns.info, '[]')\n      ) AS info\n      FROM pg_catalog.pg_index index\n      JOIN pg_catalog.pg_class class\n        ON class.oid = index.indexrelid\n      LEFT JOIN LATERAL\n        ( SELECT jsonb_agg(\"column\".attname) AS info\n          FROM pg_catalog.pg_attribute \"column\"\n          WHERE \"column\".attrelid = \"table\".oid\n            AND \"column\".attnum = ANY (index.indkey)\n        ) AS columns ON true\n      WHERE index.indrelid = \"table\".oid\n        AND index.indisprimary\n    ) primary_key ON true\n\n  -- unique constraints\n  LEFT JOIN LATERAL\n    ( SELECT jsonb_agg(jsonb_build_object('name', class.relname, 'oid', class.oid :: integer)) AS info\n      FROM pg_catalog.pg_index index\n      JOIN pg_catalog.pg_class class\n        ON class.oid = index.indexrelid\n      WHERE index.indrelid = \"table\".oid\n        AND index.indisunique\n        AND NOT index.indisprimary\n    ) unique_constraints ON true\n\n  -- foreign keys\n  LEFT JOIN LATERAL\n    ( SELECT jsonb_agg(jsonb_build_object(\n        'constraint', jsonb_build_object(\n          'name', foreign_key.constraint_name,\n          'oid', foreign_key.constraint_oid :: integer\n        ),\n        'columns', foreign_key.columns,\n        'foreign_table', jsonb_build_object(\n          'schema', foreign_key.ref_table_table_schema,\n          'name', foreign_key.ref_table\n        ),\n        'foreign_columns', foreign_key.ref_columns\n      )) AS info\n      FROM hdb_catalog.hdb_foreign_key_constraint foreign_key\n      WHERE foreign_key.table_schema = schema.nspname\n        AND foreign_key.table_name = \"table\".relname\n    ) foreign_key_constraints ON true\n\n  -- all these identify table-like things\n  WHERE \"table\".relkind IN ('r', 't', 'v', 'm', 'f', 'p');\n\nCREATE VIEW hdb_catalog.hdb_function_info_agg AS (\n  SELECT\n    function_name,\n    function_schema,\n    row_to_json (\n      (\n        SELECT\n          e\n        FROM\n          (\n            SELECT\n              description,\n              has_variadic,\n              function_type,\n              return_type_schema,\n              return_type_name,\n              return_type_type,\n              returns_set,\n              input_arg_types,\n              input_arg_names,\n              default_args,\n              exists(\n                SELECT\n                  1\n                FROM\n                  information_schema.tables\n                WHERE\n                  table_schema = return_type_schema\n                  AND table_name = return_type_name\n              )\n              OR exists(\n                SELECT\n                  1\n                FROM\n                  pg_matviews\n                WHERE\n                  schemaname = return_type_schema\n                  AND matviewname = return_type_name\n              ) AS returns_table\n          ) AS e\n      )\n    ) AS \"function_info\"\n  FROM\n    hdb_catalog.hdb_function_agg\n);\n\nCREATE TABLE hdb_catalog.hdb_query_collection\n(\n  collection_name TEXT PRIMARY KEY,\n  collection_defn JSONB NOT NULL,\n  comment TEXT NULL,\n  is_system_defined boolean default false\n);\n\nCREATE TABLE hdb_catalog.hdb_allowlist\n(\n  collection_name TEXT UNIQUE\n    REFERENCES hdb_catalog.hdb_query_collection(collection_name)\n);\n\nCREATE TABLE hdb_catalog.hdb_computed_field\n(\n  table_schema TEXT,\n  table_name TEXT,\n  computed_field_name TEXT,\n  definition JSONB NOT NULL,\n  comment TEXT NULL,\n\n  PRIMARY KEY (table_schema, table_name, computed_field_name),\n  FOREIGN KEY (table_schema, table_name) REFERENCES hdb_catalog.hdb_table(table_schema, table_name) ON UPDATE CASCADE\n);\n\nCREATE VIEW hdb_catalog.hdb_computed_field_function AS\n(\n  SELECT\n    table_schema,\n    table_name,\n    computed_field_name,\n    CASE\n      WHEN (definition::jsonb -> 'function')::jsonb ->> 'name' IS NULL THEN definition::jsonb ->> 'function'\n      ELSE (definition::jsonb -> 'function')::jsonb ->> 'name'\n    END AS function_name,\n    CASE\n      WHEN (definition::jsonb -> 'function')::jsonb ->> 'schema' IS NULL THEN 'public'\n      ELSE (definition::jsonb -> 'function')::jsonb ->> 'schema'\n    END AS function_schema\n  FROM hdb_catalog.hdb_computed_field\n);\n\nCREATE OR REPLACE FUNCTION hdb_catalog.check_violation(msg text) RETURNS bool AS\n$$\n  BEGIN\n    RAISE check_violation USING message=msg;\n  END;\n$$ LANGUAGE plpgsql;\n\nCREATE TABLE hdb_catalog.hdb_action\n(\n  action_name TEXT PRIMARY KEY,\n  action_defn JSONB NOT NULL,\n  comment TEXT NULL,\n  is_system_defined boolean default false\n);\n\nCREATE TABLE hdb_catalog.hdb_action_permission\n(\n  action_name TEXT NOT NULL,\n  role_name TEXT NOT NULL,\n  definition JSONB NOT NULL DEFAULT '{}'::jsonb,\n  comment    TEXT NULL,\n\n  PRIMARY KEY (action_name, role_name),\n  FOREIGN KEY (action_name) REFERENCES hdb_catalog.hdb_action(action_name) ON UPDATE CASCADE\n);\n\nCREATE TABLE hdb_catalog.hdb_custom_types\n(\n  custom_types jsonb NOT NULL\n);\n\nCREATE VIEW hdb_catalog.hdb_role AS\n(\n  SELECT DISTINCT role_name FROM (\n    SELECT role_name FROM hdb_catalog.hdb_permission\n    UNION ALL\n    SELECT role_name FROM hdb_catalog.hdb_action_permission\n  ) q\n);\n\nCREATE TABLE hdb_catalog.hdb_cron_triggers\n(\n  name TEXT PRIMARY KEY,\n  webhook_conf JSON NOT NULL,\n  cron_schedule TEXT NOT NULL,\n  payload JSON,\n  retry_conf JSON,\n  header_conf JSON,\n  include_in_metadata BOOLEAN NOT NULL DEFAULT FALSE,\n  comment TEXT\n);\n\n-- Add foreign key constraint from hdb_cron_events to hdb_cron_triggers\nALTER TABLE hdb_catalog.hdb_cron_events ADD CONSTRAINT\n  hdb_cron_events_trigger_name_fkey FOREIGN KEY (trigger_name)\n  REFERENCES hdb_catalog.hdb_cron_triggers(name)\n  ON UPDATE CASCADE ON DELETE CASCADE;\n\nCREATE VIEW hdb_catalog.hdb_cron_events_stats AS\n  SELECT ct.name,\n       COALESCE(ce.upcoming_events_count,0) as upcoming_events_count,\n       COALESCE(ce.max_scheduled_time, now()) as max_scheduled_time\n  FROM hdb_catalog.hdb_cron_triggers ct\n  LEFT JOIN\n  ( SELECT trigger_name, count(*) as upcoming_events_count, max(scheduled_time) as max_scheduled_time\n      FROM hdb_catalog.hdb_cron_events\n     WHERE tries = 0 and status = 'scheduled'\n     GROUP BY trigger_name\n  ) ce\n  ON ct.name = ce.trigger_name;\n\n-- Drop metadata storage table\nDROP TABLE hdb_catalog.hdb_metadata;\n\n-- Add hdb_views schema\nCREATE SCHEMA IF NOT EXISTS hdb_views;\n\n-- See Note [Migration of schema related to table event triggers log] in 42_to_43.sql\nCREATE TABLE IF NOT EXISTS hdb_catalog.event_log\n(\n  id TEXT DEFAULT hdb_catalog.gen_hasura_uuid() PRIMARY KEY,\n  schema_name TEXT NOT NULL,\n  table_name TEXT NOT NULL,\n  trigger_name TEXT NOT NULL,\n  payload JSONB NOT NULL,\n  delivered BOOLEAN NOT NULL DEFAULT FALSE,\n  error BOOLEAN NOT NULL DEFAULT FALSE,\n  tries INTEGER NOT NULL DEFAULT 0,\n  created_at TIMESTAMP DEFAULT NOW(),\n  /* when locked IS NULL the event is unlocked and can be processed */\n  locked TIMESTAMPTZ,\n  next_retry_at TIMESTAMP,\n  archived BOOLEAN NOT NULL DEFAULT FALSE\n);\n\nCREATE INDEX IF NOT EXISTS event_log_trigger_name_idx ON hdb_catalog.event_log (trigger_name);\nCREATE INDEX IF NOT EXISTS event_log_locked_idx ON hdb_catalog.event_log (locked);\nCREATE INDEX IF NOT EXISTS event_log_delivered_idx ON hdb_catalog.event_log (delivered);\nCREATE INDEX IF NOT EXISTS event_log_created_at_idx ON hdb_catalog.event_log (created_at);\n\nCREATE TABLE IF NOT EXISTS hdb_catalog.event_invocation_logs\n(\n  id TEXT DEFAULT hdb_catalog.gen_hasura_uuid() PRIMARY KEY,\n  event_id TEXT,\n  status INTEGER,\n  request JSON,\n  response JSON,\n  created_at TIMESTAMP DEFAULT NOW(),\n\n  FOREIGN KEY (event_id) REFERENCES hdb_catalog.event_log (id)\n);\n\nCREATE INDEX IF NOT EXISTS event_invocation_logs_event_id_idx ON hdb_catalog.event_invocation_logs (event_id);\n\nCREATE OR REPLACE FUNCTION\n  hdb_catalog.insert_event_log(schema_name text, table_name text, trigger_name text, op text, row_data json)\n  RETURNS text AS $$\n  DECLARE\n    id text;\n    payload json;\n    session_variables json;\n    server_version_num int;\n    trace_context json;\n  BEGIN\n    id := gen_random_uuid();\n    server_version_num := current_setting('server_version_num');\n    IF server_version_num >= 90600 THEN\n      session_variables := current_setting('hasura.user', 't');\n      trace_context := current_setting('hasura.tracecontext', 't');\n    ELSE\n      BEGIN\n        session_variables := current_setting('hasura.user');\n      EXCEPTION WHEN OTHERS THEN\n                  session_variables := NULL;\n      END;\n      BEGIN\n        trace_context := current_setting('hasura.tracecontext');\n      EXCEPTION WHEN OTHERS THEN\n        trace_context := NULL;\n      END;\n    END IF;\n    payload := json_build_object(\n      'op', op,\n      'data', row_data,\n      'session_variables', session_variables,\n      'trace_context', trace_context\n    );\n    INSERT INTO hdb_catalog.event_log\n                (id, schema_name, table_name, trigger_name, payload)\n    VALUES\n    (id, schema_name, table_name, trigger_name, payload);\n    RETURN id;\n  END;\n$$ LANGUAGE plpgsql;\n","prepared":false,"error":{"exec_status":"FatalError","hint":null,"message":"insert or update on table \"hdb_cron_events\" violates foreign key constraint \"hdb_cron_events_trigger_name_fkey\"","status_code":"23503","description":"Key (trigger_name)=(foo) is not present in table \"hdb_cron_triggers\"."},"arguments":[]},"path":"$","error":"database query error","code":"unexpected"}
